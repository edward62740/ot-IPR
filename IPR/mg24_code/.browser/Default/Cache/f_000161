{"html":"\n      <article>\n        <h1 id=\"power-manager\">Power Manager<\/h1><h2 id=\"overview\">Overview<\/h2><p>Power manager is a platform level software module that manages the system's\nenergy modes. Its main purpose is to transition the system to a low energy mode\nwhen the processor has nothing to execute. The energy mode the system will\ntransition to is determined each time the system goes to sleep using\nrequirements. These requirements are set by the different software modules\n(drivers, stacks, application code, etc.). Power manager also ensures a\nstrict control of some power-intensive resources, such as the high frequency\nexternal oscillator (normally called HFXO or SYXO). Power Manager also offers a\nnotification mechanism through which any piece of software module can be notified of\nenergy mode transitions through callbacks.<\/p><p><strong>Note<\/strong> : Sleep Driver is deprecated. Use Power Manager for all sleep-related operations. See <a href=\"#https://www.silabs.com/documents/public/application-notes/an1358-migrating-from-sleep-driver-to-power-manager.pdf\">AN1358: Migrating from Sleep Driver to Power Manager<\/a> for information on migrating from Sleep Driver to Power Manager.<\/p><h2 id=\"energy-modes-overview\">Energy modes overview<\/h2><p>As a general rule, the following energy modes are available. The description\nprovides an overview of what functionalities are lost in comparison to the\nprevious energy mode.<\/p><table>\n<thead>\n<tr>\n<th>Energy Mode<\/th><th>Description<\/th><\/tr>\n<\/thead>\n<tbody>\n<tr>\n<td>EM0<\/td><td>System is fully operational. All peripherals are available. The CPU is executing code.<\/td><\/tr>\n<tr>\n<td>EM1<\/td><td>The CPU is in sleep mode and is not executing any code.<\/td><\/tr>\n<tr>\n<td>EM2<\/td><td>High frequency clock sources are shut down. Peripherals that require a high frequency clock are unavailable or have limited functionalities.<\/td><\/tr>\n<tr>\n<td>EM3<\/td><td>Low frequency clock sources are shut down. Peripherals that require a low frequency clock are unavailable.<\/td><\/tr>\n<\/tbody>\n<\/table>\n<p>*<em>The EM4 energy mode has been omitted from this list as it is not supported\nby power manager. See section <a href=\"#enteringem4\">Entering EM4<\/a> for more \ndetails.<\/em><\/p><p>Once the system enters a low energy mode, the way to wake it up to EM0 is via\ninterruptions. Once an interruption occurs, the system goes back to the\nhighest energy mode (EM0). However, if the system was in a deep sleep mode\n(EM2 or EM3), the system may not wake up in a fully restored mode. See section\nWaking up from sleep for more information.<\/p><p>For more information on the different energy modes, refer to your device's user\nmanual.<\/p><h2 id=\"power-manager-design-considerations\">Power manager design considerations<\/h2><p>Power manager acts as the middleman between the different software modules\nand the device.<\/p><p><img src=\"/resources/gecko-platform/3.0/service/power_manager/module.png\">Power Manager Interactions<\/p><p>Any piece of software can interact with power manager. There are two main\ninterfaces, as described below.<\/p><h3 id=\"requirements\">Requirements<\/h3><p>APIs allow you to add and remove requirements on energy modes (EM1, EM2 and\nEM3). Refer to your chip's reference manual to determine what operations are\npossible in each energy mode.<\/p><p>The normal use case for these APIs is to add a requirement on a given energy\nmode before starting a given operation (using one or more peripherals) and\nremoving this requirement once the operation is completed. The more efficient\nand refined are your operations and the add/remove requirements blocks, the\nmore power efficient your application will be.<\/p><p>For example, when transmitting data on a USART, the system can go to sleep.\nHowever, it can only sleep in EM1 mode as otherwise the USART would stop\nworking. The correct way of handling this is to add a requirement on EM1 when\nthe transfer is set up, and remove the requirement on EM1 once the transfer\ncomplete ISR is triggered.<\/p><p>The requirements are added and removed via the following APIs:<\/p><pre><code>void sl_power_manager_add_em_requirement(sl_power_manager_em_t em);\nvoid sl_power_manager_remove_em_requirement(sl_power_manager_em_t em);<\/code><\/pre><p>You must always call the functions <code>sl_power_manager_add_em_requirement()<\/code> and\n<code>sl_power_manager_remove_em_requirement()<\/code> in pair. If you omit to remove a\nrequirement previously added on a given energy mode, that will cause your\napplication to be unable to sleep to a lower energy mode. <\/p><p>You can add and remove requirements from ISR. This is useful to perform a full\nrestore of the different clock sources when waking-up from a deep sleep energy\nmode (more information on that in the\n<a href=\"#wakingfromdeepsleep\">Waking up from deep sleep<\/a> section).\nUpon return from a function call to <code>sl_power_manager_add_em_requirement()<\/code>,\npower manager guarantees that all resources related to the requested energy\nmode are fully restored and available. You should however add requirements from\nan ISR only when this is absolutely necessary, as this can impact power\nconsumption and interrupt latency.<\/p><p>*<em>Note that software provided by Silicon Labs as part of the different SDKs\nhas, for the most part, a proper and efficient integration with power\nmanager. You don't have to add and remove requirements for operations\nperformed by these SDK functions unless stated otherwise in the module's user\nmanual.<\/em><\/p><h3 id=\"notifications\"><a name=\"notifications\"><\/a>Notifications<\/h3><p>Power manager offers a notification mechanism. This mechanism allows any\npiece of software to be notified of any energy mode transition. When\ntransitioning from a high energy mode to a lower one (for example, from EM0 to\nEM2), the listeners are notified before the transition. When transitioning from\na low energy mode to a high energy mode (from EM2 to EM0, for example), the\nlisteners are notified after the transition is completed. The main purpose of\nthese notifications is for the different software modules to \"adapt\" to the new\nenergy mode applied. For instance, a given software module may not need to have\na requirement on EM1 to perform a given operation, but may have to do some\nmodifications to continue to perform its operation in EM2. These modifications\ncan be applied in the notification callback. You must use these notifications\nfrom your application if you need to perform such operations. Note that the\nnotifications may be called from an ISR context.<\/p><p>The following API is available to subscribe to notifications. The events to\nsubscribe to are configurable. <\/p><pre><code>void sl_power_manager_subscribe_em_transition_event(sl_power_manager_em_transition_event_handle_t     *event_handle,\n                                                    const sl_power_manager_em_transition_event_info_t *event_info);<\/code><\/pre><p><strong><em>*Note that it is not possible to add and remove requirements from a notification.<\/em><\/strong><\/p><h2 id=\"the-process-of-entering-a-sleep-mode\">The process of entering a sleep mode<\/h2><h3 id=\"when-using-an-operating-system\">When using an operating system<\/h3><p>When your application uses an Operating System (Micrium OS kernel or FreeRTOS,\nfor example), the process of going to sleep is fully handled by the OS. The\nsystem will automatically enter the lowest possible energy mode (depending on\nthe requirements currently set) when the OS enters idle mode (i.e. when all the\ntasks are pending on something, delayed or suspended). Power manager will\nensure the system resumes its operations as soon as a task is resumed, posted\nor that its delay expires.<\/p><h3 id=\"baremetal-applications\">Baremetal applications<\/h3><p>When on a baremetal environment, the process of bringing the system into sleep\nis your application's duty. You are required to call a function named\n<code>sl_power_manager_sleep()<\/code> when your application is idling. Once you call this\nfunction, power manager will enter in a sleep loop and won't exit this loop\nuntil a system wakeup is requested after an ISR. Two entry points to this sleep\nloop are provided and used by power manager to determine if it is safe to\nenter/return to a low energy mode. These entry points are implemented as\nfunction callbacks. Power manager offers a contributions mechanism, as\nmultiple different software modules can contribute to the decision. The\nsoftware provided by Silicon Labs offers a full integration by contributing to\nthese callbacks when needed.<\/p><table>\n<thead>\n<tr>\n<th>Entry point<\/th><th>Description<\/th><th>Algorithm description<\/th><\/tr>\n<\/thead>\n<tbody>\n<tr>\n<td><code>is_ok_to_sleep<\/code><\/td><td>This entry point is only called once at the beginning of the <code>sl_power_manager_sleep()<\/code> function. It is used to query your application to ensure that no last minute event occurred that would normally prevent the system from entering sleep.<\/td><td>The functions provided by the different contributors are called one by one and return a boolean value.<\/td><\/tr>\n<tr>\n<td><code>sleep_on_isr_exit<\/code><\/td><td>This function is called each time an interrupt (or multiple interrupts) wakes the system up, before re-entering sleep. It is used to determine if the system should go back to sleep or wake-up.<\/td><td>The functions provided by the different software modules are called one by one and return one of these states:<ul><li><code>SL_POWER_MANAGER_IGNORE<\/code>: Returned when the software module did not cause the system wakeup.<\/li><li><code>SL_POWER_MANAGER_SLEEP<\/code>: Returned when the software module did cause the system wakeup, but the system should go back to sleep.<\/li><li><code>SL_POWER_MANAGER_WAKEUP<\/code>: Returned when the software module did cause the system wakeup, and the system should not go back to sleep.<\/li><\/ul> If any function returns <code>SL_POWER_MANAGER_WAKEUP<\/code>, the decision is taken to not go back to sleep. If any software module return <code>SL_POWER_MANAGER_SLEEP<\/code> and none return <code>SL_POWER_MANAGER_WAKEUP<\/code>, the decision is taken to go back to sleep. Any other combinations will result in a decision of not going back to sleep.<\/td><\/tr>\n<\/tbody>\n<\/table>\n<p>Two fixed functions are available for your application to implement and\ncontribute to these two entry points decision:<\/p><ul>\n<li><code>app_is_ok_to_sleep()<\/code><\/li><li><code>app_sleep_on_isr_exit()<\/code><\/li><\/ul>\n<h2 id=\"waking-up-from-sleep\">Waking up from sleep<\/h2><p>The device wakes up from sleep when an interruption occurs. This causes the\nsystem to go back to the EM0 energy mode and the CPU to resume code execution\n(and execute interrupt's ISR). The state of the system when executing the\ninterrupt's ISR will however differ depending on the energy mode the system was\nsleeping into. <\/p><table>\n<thead>\n<tr>\n<th>Energy mode the system was sleeping into<\/th><th>System restore state<\/th><\/tr>\n<\/thead>\n<tbody>\n<tr>\n<td>EM1<\/td><td>On ISR entry, the system will be fully restored as it was before entering sleep mode.<\/td><\/tr>\n<tr>\n<td>EM2 or EM3 (deep sleep)<\/td><td>Depending on the wakeup source, some clock sources may not be restored. See following section for more information.<\/td><\/tr>\n<\/tbody>\n<\/table>\n<h3 id=\"waking-up-from-deep-sleep\"><a name=\"wakingfromdeepsleep\"><\/a>Waking up from deep sleep<\/h3><p>When waking up from deep sleep and executing the interrupt's ISR, the device\nonly restores a fast startup RC oscillator to provide a high frequency clock\nsource for the CPU. The reason being that the process of restoring all the\nclock sources can be time consuming and requires energy. Depending on the\noperation that needs to be performed in these ISR, having only one RC\noscillator clocking the CPU may be sufficient. It is more energy efficient to\nnot restore all the clock sources in the cases where an ISR with simple\nprocessing is executed and the system can get back to a deep sleep mode.<\/p><p>See the sections <a href=\"#synchronousevents\">Synchronous events<\/a> and \n<a href=\"#asynchronousevents\">Asynchronous events<\/a> for more information on the events\nthat cause a full clock sources restore by power manager. Note that when\nthe system gets back to thread mode (if an os task is posted or if a decision\nto wake-up is taken using the <code>sleep_on_isr_exit<\/code> entry point in a baremetal\napplication) power manager will always perform a full restore before. <\/p><p>Following table provides examples of clock sources that are not always\nautomatically restored when waking up from deep sleep.<\/p><table>\n<thead>\n<tr>\n<th>Energy mode the system was sleeping to<\/th><th>Clock sources<\/th><\/tr>\n<\/thead>\n<tbody>\n<tr>\n<td>EM2<\/td><td>HFXO/SYXO, DPLL<\/td><\/tr>\n<tr>\n<td>EM3<\/td><td>Clock sources from EM2 + LFXO and LFRCO<\/td><\/tr>\n<\/tbody>\n<\/table>\n<h4 id=\"synchronous-events\"><a name=\"synchronousevents\"><\/a>Synchronous events<\/h4><p>Synchronous events are real-time timed events that are expected to occur in the\nfuture. Processing these events will require a full restore of the clock\nsources. Since the process of restoring the clock sources can be time\nconsuming, power manager will ensure to wake up in advance and proceed to a\nfull restore of the clock sources in order to be ready on time to process the\nsynchronous event.<\/p><p>To register an event that will be considered as synchronous by power\nmanager, you must use the timer functionality provided by the <code>sl_sleeptimer<\/code>\nmodule. Any timer (periodic or one-shot) created with the argument option_flags\nset to 0 will be considered as a synchronous event that requires a full restore\nof the clock sources on expiration. If you create a timer with the option flag\n<code>SL_SLEEPTIMER_NO_HIGH_PRECISION_HF_CLOCKS_REQUIRED_FLAG<\/code>, you won't have a\nguarantee that all the clock sources will be restored on expiration. For more\ninformation on how to create a timer, refer to the <code>sl_sleeptimer<\/code> user manual.<\/p><h4 id=\"asynchronous-events\"><a name=\"asynchronousevents\"><\/a>Asynchronous events<\/h4><p>Asynchronous events are any other events (ISRs) that occur in the system. Those\nevents are unexpected by their nature. When they occur and the system was deep\nsleeping, the various clock sources are not guaranteed to be restored. As for\nnormal operations, if you need to perform or initiate an operation that\nrequires some specific clock sources from your ISR, you must add a requirement\non the necessary energy mode to force a restore of the clock sources. If you\nadd a requirement on EM2, upon return of the function\n<code>sl_power_manager_add_em_requirement()<\/code> the low frequency clock sources are\nguaranteed to be available and ready. If you add a requirement on EM1, upon\nreturn of the function <code>sl_power_manager_add_em_requirement()<\/code> the high and low\nfrequency clock sources are guaranteed to be available and ready.<\/p><p>Note that a call to <code>sl_power_manager_add_em_requirement()<\/code> that triggers a\nhigh frequency clock restore will take some time to execute and will stop the\nCPU for some time. If this is a problem for your application, consider making\nsure that a requirement on EM1 is added before entering sleep mode. <\/p><p>The time required to restore the clock sources depends on many factors. Refer\nto your device's datasheet and user manual for more details.<\/p><h2 id=\"tips-and-tricks-to-optimize-your-power-consumption-with-power-manager\">Tips and tricks to optimize your power consumption with power manager<\/h2><h3 id=\"refine-your-requirement-blocks-as-much-as-possible\">Refine your requirement blocks as much as possible<\/h3><p>You may be tempted to have a very broad coverage of operations between the\nmoment you add a requirement and the moment you remove it. While this offers\nsome simplicity benefits, this is not very efficient. In order to achieve\nbetter power consumption, the periods where a requirement is added must be as\nsmall and as refined as possible. This will avoid cases where the system enters\nsleep mode in a high energy mode when it could enter a lower one.<\/p><h3 id=\"fine-tune-the-restore-time-overhead\">Fine tune the restore time overhead<\/h3><p>As described earlier, restoring the clock sources (especially the\nhigh-frequency clock sources) can be time consuming. Since this restore time\ncan vary depending on many factors (external crystal type, ambient temperature,\netc) power manager implements a mechanism where it measures the time\nrequired to restore some high frequency clock sources. This restore time is\nused when deep sleeping to trigger a clock sources restore in advance in\nexpectation of an upcoming synchronous event. In order to maintain real-time\nresponsiveness of your application, it is vital to have a restore time that is\nnot too short, as that would cause the clock sources not to be ready on time.\nFor that reason, power manager always adds a safety margin to the restore\ntime it measures. However, since the system consumes more power when these\nclock sources are restored, the shorter this restore time is, the better will\nthe energy consumption be. The functions\n<code>sl_power_manager_schedule_wakeup_get_restore_overhead_tick()<\/code> and\n<code>sl_power_manager_schedule_wakeup_set_restore_overhead_tick()<\/code> are offered to\nfine tune this safety overhead. <\/p><p>Please note that because of hardware limitations on series 2 devices supporting\nEM1P energy mode, power manager is not always able to measure the high \nfrequency clock restore time. Since the default restore time has a large \nmargin, it is possible that the restore time remains longer than needed.\nTherefore, if higher power consumption than expected is observed, \n<code>sl_power_manager_schedule_wakeup_set_restore_overhead_tick()<\/code> can be used to\nreduce the restore time by passing a negative overhead.<\/p><h2 id=\"entering-em4\"><a name=\"enteringem4\"><\/a>Entering EM4<\/h2><p>Power manager doesn't support the EM4 energy mode. As such, it will never\ntake the decision to enter this energy mode. However, that doesn't prevent you\nfrom using this energy mode.<\/p><p>As described in this document, power manager bases its decisions of\nsleeping to a given energy mode on requirements that are added and removed\nby the diferent software modules. Given the very different nature of EM4, this\napproach is not well suited to take a decision to enter this energy mode. Most\nof the time, when the decision is taken to enter EM4, the sleep period will be\nfairly long, and the wakeup source will be quite basic (GPIO interrupt, low\nenergy timer compare match, etc.). As such, in most circumstances, your\napplication is in the best position to take this decision.<\/p><p>A good approach for your application is to enter EM4 when power manager is\nabout to enter a low energy mode. This is possible by subscribing to a\nnotification of entering a low energy mode (see <a href=\"#notifications\">Notifications<\/a> \nfor more details). In this notification callback, you can evaluate if you want\nto enter EM4 instead. To enter EM4, you can simply call the function:\n<code>EMU_EnterEM4()<\/code>. Keep in mind that waking up from this energy mode will result\nin a reset of the device. Restoring previous states after wakeup is your\napplication's duty. Refer to your device's reference manual for more\ninformation on the EM4 energy mode.<\/p><p>However, be aware that entering the EM4 energy mode will abort any operation\nthat require a higher energy mode. If, for example, you need a transfer to\ncomplete on the UART via DMA before entering EM4, you must wait for its\ncompletion. This can be done by polling the STATUS register of the controller.<\/p>\n      <div ub-in-page=\"6062051aebaf71079a7b414b\"><\/div>\n      <\/article>\n    ","url":"http://docs.silabs.com/gecko-platform/4.0/service/power_manager/overview","status":"success"}
